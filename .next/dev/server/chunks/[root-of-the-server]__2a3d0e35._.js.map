{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///D:/hack/FinPath/src/lib/db.ts"],"sourcesContent":["import mongoose from 'mongoose';\r\n\r\nconst MONGODB_URI = process.env.MONGO_URI;\r\n\r\nif (!MONGODB_URI) {\r\n    throw new Error(\r\n        'Please define the MONGO_URI environment variable inside .env.local'\r\n    );\r\n}\r\n\r\n/**\r\n * Global is used here to maintain a cached connection across hot reloads\r\n * in development. This prevents connections growing exponentially\r\n * during API Route usage.\r\n */\r\nlet cached = (global as any).mongoose;\r\n\r\nif (!cached) {\r\n    cached = (global as any).mongoose = { conn: null, promise: null };\r\n}\r\n\r\nasync function connectDB() {\r\n    if (cached.conn) {\r\n        return cached.conn;\r\n    }\r\n\r\n    if (!cached.promise) {\r\n        const opts = {\r\n            bufferCommands: false,\r\n        };\r\n\r\n        cached.promise = mongoose.connect(MONGODB_URI!, opts).then((mongoose) => {\r\n            return mongoose;\r\n        });\r\n    }\r\n\r\n    try {\r\n        cached.conn = await cached.promise;\r\n    } catch (e) {\r\n        cached.promise = null;\r\n        throw e;\r\n    }\r\n\r\n    return cached.conn;\r\n}\r\n\r\nexport default connectDB;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,SAAS;AAEzC,IAAI,CAAC,aAAa;IACd,MAAM,IAAI,MACN;AAER;AAEA;;;;CAIC,GACD,IAAI,SAAS,yDAAgB,QAAQ;AAErC,IAAI,CAAC,QAAQ;IACT,SAAS,yDAAgB,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AACpE;AAEA,eAAe;IACX,IAAI,OAAO,IAAI,EAAE;QACb,OAAO,OAAO,IAAI;IACtB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACjB,MAAM,OAAO;YACT,gBAAgB;QACpB;QAEA,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,aAAc,MAAM,IAAI,CAAC,CAAC;YACxD,OAAO;QACX;IACJ;IAEA,IAAI;QACA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IACtC,EAAE,OAAO,GAAG;QACR,OAAO,OAAO,GAAG;QACjB,MAAM;IACV;IAEA,OAAO,OAAO,IAAI;AACtB;uCAEe"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///D:/hack/FinPath/src/models/User.ts"],"sourcesContent":["import mongoose from 'mongoose';\r\n\r\nconst UserSchema = new mongoose.Schema({\r\n    username: {\r\n        type: String,\r\n        required: true,\r\n        unique: true,\r\n        trim: true,\r\n        minlength: 3,\r\n    },\r\n    email: {\r\n        type: String,\r\n        required: true,\r\n        unique: true,\r\n        trim: true,\r\n        lowercase: true,\r\n    },\r\n    password: {\r\n        type: String,\r\n        required: true,\r\n        minlength: 6,\r\n    },\r\n    profileImage: {\r\n        type: String, // Base64 encoded image\r\n        default: \"\",\r\n    },\r\n    bio: {\r\n        type: String,\r\n        default: \"\",\r\n        maxlength: 500,\r\n    },\r\n    location: {\r\n        type: String,\r\n        default: \"\",\r\n    },\r\n    jobTitle: {\r\n        type: String,\r\n        default: \"\",\r\n    },\r\n    xp: {\r\n        type: Number,\r\n        default: 0,\r\n    },\r\n    level: {\r\n        type: Number,\r\n        default: 1,\r\n    },\r\n    completedLessons: {\r\n        type: [Number],\r\n        default: [],\r\n    },\r\n    currentLesson: {\r\n        type: Number,\r\n        default: 1,\r\n    },\r\n    budgetChallenge: {\r\n        isActive: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        startDate: {\r\n            type: Date,\r\n        },\r\n        lastCheckIn: {\r\n            type: Date,\r\n        },\r\n        daysCompleted: {\r\n            type: Number,\r\n            default: 0,\r\n        },\r\n    },\r\n    badges: [\r\n        {\r\n            type: String,\r\n        },\r\n    ],\r\n    lastLogin: {\r\n        type: Date,\r\n    },\r\n    streak: {\r\n        type: Number,\r\n        default: 0,\r\n    },\r\n    joinedChallenges: {\r\n        type: [String],\r\n        default: [],\r\n    },\r\n    completedChallenges: {\r\n        type: [String],\r\n        default: [],\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now,\r\n    },\r\n});\r\n\r\n// Force model recompilation in dev to pick up schema changes\r\nif (process.env.NODE_ENV === 'development') {\r\n    delete mongoose.models.User;\r\n}\r\n\r\nexport default mongoose.models.User || mongoose.model('User', UserSchema);\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,aAAa,IAAI,oHAAQ,CAAC,MAAM,CAAC;IACnC,UAAU;QACN,MAAM;QACN,UAAU;QACV,QAAQ;QACR,MAAM;QACN,WAAW;IACf;IACA,OAAO;QACH,MAAM;QACN,UAAU;QACV,QAAQ;QACR,MAAM;QACN,WAAW;IACf;IACA,UAAU;QACN,MAAM;QACN,UAAU;QACV,WAAW;IACf;IACA,cAAc;QACV,MAAM;QACN,SAAS;IACb;IACA,KAAK;QACD,MAAM;QACN,SAAS;QACT,WAAW;IACf;IACA,UAAU;QACN,MAAM;QACN,SAAS;IACb;IACA,UAAU;QACN,MAAM;QACN,SAAS;IACb;IACA,IAAI;QACA,MAAM;QACN,SAAS;IACb;IACA,OAAO;QACH,MAAM;QACN,SAAS;IACb;IACA,kBAAkB;QACd,MAAM;YAAC;SAAO;QACd,SAAS,EAAE;IACf;IACA,eAAe;QACX,MAAM;QACN,SAAS;IACb;IACA,iBAAiB;QACb,UAAU;YACN,MAAM;YACN,SAAS;QACb;QACA,WAAW;YACP,MAAM;QACV;QACA,aAAa;YACT,MAAM;QACV;QACA,eAAe;YACX,MAAM;YACN,SAAS;QACb;IACJ;IACA,QAAQ;QACJ;YACI,MAAM;QACV;KACH;IACD,WAAW;QACP,MAAM;IACV;IACA,QAAQ;QACJ,MAAM;QACN,SAAS;IACb;IACA,kBAAkB;QACd,MAAM;YAAC;SAAO;QACd,SAAS,EAAE;IACf;IACA,qBAAqB;QACjB,MAAM;YAAC;SAAO;QACd,SAAS,EAAE;IACf;IACA,WAAW;QACP,MAAM;QACN,SAAS,KAAK,GAAG;IACrB;AACJ;AAEA,6DAA6D;AAC7D,wCAA4C;IACxC,OAAO,oHAAQ,CAAC,MAAM,CAAC,IAAI;AAC/B;uCAEe,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAC,QAAQ"}},
    {"offset": {"line": 237, "column": 0}, "map": {"version":3,"sources":["file:///D:/hack/FinPath/src/app/api/auth/login/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport bcrypt from 'bcryptjs';\r\nimport jwt from 'jsonwebtoken';\r\nimport connectDB from '@/lib/db';\r\nimport User from '@/models/User';\r\n\r\nexport async function POST(req: Request) {\r\n    try {\r\n        await connectDB();\r\n\r\n        const { email, password } = await req.json();\r\n\r\n        // Validation\r\n        if (!email || !password) {\r\n            return NextResponse.json({ msg: 'Please enter all fields' }, { status: 400 });\r\n        }\r\n\r\n        // Check for user\r\n        const user = await User.findOne({ email });\r\n        if (!user) {\r\n            return NextResponse.json({ msg: 'Invalid Credentials' }, { status: 400 });\r\n        }\r\n\r\n        // Validate password\r\n        const isMatch = await bcrypt.compare(password, user.password);\r\n        if (!isMatch) {\r\n            return NextResponse.json({ msg: 'Invalid Credentials' }, { status: 400 });\r\n        }\r\n\r\n        // Streak Logic\r\n        const today = new Date();\r\n        const lastLogin = user.lastLogin ? new Date(user.lastLogin) : null;\r\n\r\n        if (lastLogin) {\r\n            const diffTime = Math.abs(today.getTime() - lastLogin.getTime());\r\n            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\r\n\r\n            // If login is next day, increment streak\r\n            // Note: simple check logic, can be made more robust with date comparison (ignoring time)\r\n            const isNextDay = diffDays > 0 && diffDays <= 2 && today.getDate() !== lastLogin.getDate();\r\n\r\n            if (isNextDay) {\r\n                user.streak = (user.streak || 0) + 1;\r\n            } else if (diffDays > 2) {\r\n                // Missed a day\r\n                user.streak = 1;\r\n            }\r\n            // else: same day, keep streak\r\n        } else {\r\n            // First login ever or since feature added\r\n            user.streak = 1;\r\n        }\r\n\r\n        user.lastLogin = today;\r\n        await user.save();\r\n\r\n        // Create token\r\n        const payload = {\r\n            user: {\r\n                id: user.id,\r\n            },\r\n        };\r\n\r\n        const token = jwt.sign(\r\n            payload,\r\n            process.env.JWT_SECRET || 'fallback_secret',\r\n            { expiresIn: 360000 }\r\n        );\r\n\r\n        return NextResponse.json({\r\n            token,\r\n            user: {\r\n                id: user.id,\r\n                username: user.username,\r\n                email: user.email,\r\n                xp: user.xp,\r\n                level: user.level,\r\n                badges: user.badges,\r\n                streak: user.streak,\r\n            },\r\n        });\r\n    } catch (err: any) {\r\n        console.error('Login Error:', err.message);\r\n        return NextResponse.json({ msg: 'Server error' }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEO,eAAe,KAAK,GAAY;IACnC,IAAI;QACA,MAAM,IAAA,6HAAS;QAEf,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,IAAI;QAE1C,aAAa;QACb,IAAI,CAAC,SAAS,CAAC,UAAU;YACrB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,KAAK;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QAEA,iBAAiB;QACjB,MAAM,OAAO,MAAM,kIAAI,CAAC,OAAO,CAAC;YAAE;QAAM;QACxC,IAAI,CAAC,MAAM;YACP,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,KAAK;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,oBAAoB;QACpB,MAAM,UAAU,MAAM,8IAAM,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ;QAC5D,IAAI,CAAC,SAAS;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,KAAK;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,eAAe;QACf,MAAM,QAAQ,IAAI;QAClB,MAAM,YAAY,KAAK,SAAS,GAAG,IAAI,KAAK,KAAK,SAAS,IAAI;QAE9D,IAAI,WAAW;YACX,MAAM,WAAW,KAAK,GAAG,CAAC,MAAM,OAAO,KAAK,UAAU,OAAO;YAC7D,MAAM,WAAW,KAAK,IAAI,CAAC,WAAW,CAAC,OAAO,KAAK,KAAK,EAAE;YAE1D,yCAAyC;YACzC,yFAAyF;YACzF,MAAM,YAAY,WAAW,KAAK,YAAY,KAAK,MAAM,OAAO,OAAO,UAAU,OAAO;YAExF,IAAI,WAAW;gBACX,KAAK,MAAM,GAAG,CAAC,KAAK,MAAM,IAAI,CAAC,IAAI;YACvC,OAAO,IAAI,WAAW,GAAG;gBACrB,eAAe;gBACf,KAAK,MAAM,GAAG;YAClB;QACA,8BAA8B;QAClC,OAAO;YACH,0CAA0C;YAC1C,KAAK,MAAM,GAAG;QAClB;QAEA,KAAK,SAAS,GAAG;QACjB,MAAM,KAAK,IAAI;QAEf,eAAe;QACf,MAAM,UAAU;YACZ,MAAM;gBACF,IAAI,KAAK,EAAE;YACf;QACJ;QAEA,MAAM,QAAQ,kJAAG,CAAC,IAAI,CAClB,SACA,QAAQ,GAAG,CAAC,UAAU,IAAI,mBAC1B;YAAE,WAAW;QAAO;QAGxB,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB;YACA,MAAM;gBACF,IAAI,KAAK,EAAE;gBACX,UAAU,KAAK,QAAQ;gBACvB,OAAO,KAAK,KAAK;gBACjB,IAAI,KAAK,EAAE;gBACX,OAAO,KAAK,KAAK;gBACjB,QAAQ,KAAK,MAAM;gBACnB,QAAQ,KAAK,MAAM;YACvB;QACJ;IACJ,EAAE,OAAO,KAAU;QACf,QAAQ,KAAK,CAAC,gBAAgB,IAAI,OAAO;QACzC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,KAAK;QAAe,GAAG;YAAE,QAAQ;QAAI;IACpE;AACJ"}}]
}